# This stub file was automatically generated by mypy's `stubgen`,
# The file was then modified manually; if you get a build failure
# that leads you here, feel free to modify the file manually as well.
#
# This file may diverge from the runtime/native implementation of the code,
# as long as the interface remains the same. (i.e.: pure-Python classes
# may be listed here even if they override/inherit from native classes.)

import numpy as np
from numpy.typing import NDArray
from typing import BinaryIO, List, Literal, Optional, Union, overload

class ReadableAudioFile(AudioFile):
    @overload
    def __init__(self, filename: str): ...
    @overload
    def __init__(self, file_like: BinaryIO): ...
    def __enter__(self) -> ReadableAudioFile: ...
    def __exit__(self): ...
    def close(self): ...
    @property
    def closed(self): ...  # read-only
    @property
    def duration(self): ...  # read-only
    @property
    def file_dtype(self): ...  # read-only
    @property
    def samplerate(self) -> float: ...  # read-only
    @property
    def num_channels(self) -> int: ...  # read-only
    @property
    def frames(self) -> int: ...  # read-only
    @property
    def name(self) -> Optional[str]: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def seek(self, index_in_frames: int): ...
    def read(self, num_frames: int) -> NDArray[np.float32]: ...
    def read_raw(self, num_frames: int) -> Union[NDArray[np.int16], NDArray[np.float32]]: ...

class WriteableAudioFile(AudioFile):
    @overload
    def __init__(
        self,
        filename: str,
        samplerate: Optional[float] = ...,
        num_channels: int = ...,
        bit_depth: int = ...,
        quality: Union[None, str, float] = ...,
    ): ...
    @overload
    def __init__(
        self,
        file_like: BinaryIO,
        samplerate: Optional[float] = ...,
        num_channels: int = ...,
        bit_depth: int = ...,
        quality: Union[None, str, float] = ...,
    ): ...
    def __enter__(self) -> WriteableAudioFile: ...
    def __exit__(self): ...
    def close(self): ...
    @property
    def closed(self) -> bool: ...  # read-only
    @property
    def file_dtype(self) -> str: ...  # read-only
    @property
    def frames(self) -> int: ...  # read-only
    @property
    def samplerate(self) -> float: ...  # read-only
    @property
    def quality(self) -> Union[None, str, float]: ...  # read-only
    @property
    def num_channels(self) -> int: ...  # read-only
    def flush(self): ...
    @overload
    def write(self, audio_frames: NDArray[np.int8]): ...
    @overload
    def write(self, audio_frames: NDArray[np.int16]): ...
    @overload
    def write(self, audio_frames: NDArray[np.int32]): ...
    @overload
    def write(self, audio_frames: NDArray[np.float32]): ...

class AudioFile(object):
    @overload
    def __new__(cls, filename: str, mode: Literal["r"] = ...) -> ReadableAudioFile: ...
    @overload
    def __new__(cls, file_like: BinaryIO, mode: Literal["r"] = ...) -> ReadableAudioFile: ...
    @overload
    def __new__(
        cls,
        filename: str,
        mode: Literal["w"],
        samplerate: Optional[float] = ...,
        num_channels: int = ...,
        bit_depth: int = ...,
        quality: Union[None, str, float] = ...,
    ) -> WriteableAudioFile: ...
    @overload
    def __new__(
        cls,
        file_like: BinaryIO,
        mode: Literal["w"],
        samplerate: Optional[float] = ...,
        num_channels: int = ...,
        bit_depth: int = ...,
        quality: Union[None, str, float] = ...,
    ) -> WriteableAudioFile: ...

def get_supported_read_formats() -> List[str]: ...
def get_supported_write_formats() -> List[str]: ...
